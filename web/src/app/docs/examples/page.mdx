export const metadata = {
  title: "Examples",
  description: "Real-world examples of using MCPX for browser automation.",
};

# Examples

Real-world examples of using MCPX for browser automation tasks.

## Basic Examples

### Opening a Website

The simplest MCPX operation is opening a website:

```javascript
const client = new MCPXClient();
await client.openTab("https://google.com");
```

```python
client = MCPXClient()
await client.open_tab("https://google.com")
```

### Clicking Elements

Click on page elements using CSS selectors:

```javascript
// Click a button
await client.clickElement("#search-button");

// Click a link
await client.clickElement('a[href="/login"]');

// Click by text content
await client.clickElement('button:contains("Submit")');
```

### Filling Forms

Type text into input fields:

```javascript
// Clear and type new text
await client.typeText("#username", "john@example.com", true);

// Append to existing text
await client.typeText("#message", " Additional text", false);
```

## Intermediate Examples

### Login Automation

Complete login flow automation:

```javascript
async function loginToSite(email, password) {
  const client = new MCPXClient();

  try {
    // Open the login page
    await client.openTab("https://example.com/login");

    // Wait for page to load
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // Fill in credentials
    await client.typeText("#email", email, true);
    await client.typeText("#password", password, true);

    // Submit the form
    await client.clickElement("#login-button");

    // Wait for redirect
    await new Promise((resolve) => setTimeout(resolve, 3000));

    console.log("Login completed successfully");
  } catch (error) {
    console.error("Login failed:", error);
  }
}

// Usage
await loginToSite("user@example.com", "mypassword");
```

### Form Automation

Fill out complex forms:

```javascript
async function fillContactForm(formData) {
  const client = new MCPXClient();

  try {
    await client.openTab("https://example.com/contact");

    // Fill text fields
    await client.typeText("#name", formData.name, true);
    await client.typeText("#email", formData.email, true);
    await client.typeText("#phone", formData.phone, true);

    // Fill textarea
    await client.typeText("#message", formData.message, true);

    // Check checkbox if needed
    if (formData.subscribe) {
      await client.clickElement("#newsletter-checkbox");
    }

    // Submit form
    await client.clickElement("#submit-button");

    console.log("Form submitted successfully");
  } catch (error) {
    console.error("Form submission failed:", error);
  }
}

// Usage
await fillContactForm({
  name: "John Doe",
  email: "john@example.com",
  phone: "+1234567890",
  message: "Hello, I have a question...",
  subscribe: true,
});
```

## Advanced Examples

### E-commerce Automation

Multi-step checkout process:

```javascript
async function ecommerceCheckout(items, customerInfo) {
  const client = new MCPXClient();

  try {
    // Step 1: Add items to cart
    for (const item of items) {
      await client.openTab(item.url);
      await new Promise((resolve) => setTimeout(resolve, 1000));

      // Select size/color if needed
      if (item.size) {
        await client.clickElement(`[data-size="${item.size}"]`);
      }

      // Add to cart
      await client.clickElement("#add-to-cart");
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }

    // Step 2: Go to cart
    await client.clickElement("#cart-link");
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // Step 3: Proceed to checkout
    await client.clickElement("#checkout-button");
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // Step 4: Fill shipping information
    await client.typeText("#shipping-name", customerInfo.name, true);
    await client.typeText("#shipping-address", customerInfo.address, true);
    await client.typeText("#shipping-city", customerInfo.city, true);
    await client.typeText("#shipping-zip", customerInfo.zip, true);

    // Step 5: Continue to payment
    await client.clickElement("#continue-to-payment");

    console.log("Reached payment page - manual payment required");
  } catch (error) {
    console.error("Checkout process failed:", error);
  }
}

// Usage
await ecommerceCheckout(
  [
    { url: "https://shop.example.com/product/123", size: "M" },
    { url: "https://shop.example.com/product/456", size: "L" },
  ],
  {
    name: "John Doe",
    address: "123 Main St",
    city: "Anytown",
    zip: "12345",
  }
);
```

### Web Scraping with Pagination

Scrape data across multiple pages:

```javascript
async function scrapeJobListings(searchQuery, maxPages = 5) {
  const client = new MCPXClient();
  const allJobs = [];

  try {
    // Open job search site
    await client.openTab("https://jobs.example.com");
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // Search for jobs
    await client.typeText("#job-search", searchQuery, true);
    await client.clickElement("#search-button");
    await new Promise((resolve) => setTimeout(resolve, 3000));

    for (let page = 1; page <= maxPages; page++) {
      console.log(`Scraping page ${page}...`);

      // Get current page content
      const snapshot = await client.call("snapshot", {
        url: "current", // Use current active tab
      });

      // Parse job listings from the page
      const parser = new DOMParser();
      const doc = parser.parseFromString(snapshot.result.dom, "text/html");

      const jobElements = doc.querySelectorAll(".job-listing");

      for (const jobEl of jobElements) {
        const job = {
          title: jobEl.querySelector(".job-title")?.textContent?.trim(),
          company: jobEl.querySelector(".company-name")?.textContent?.trim(),
          location: jobEl.querySelector(".job-location")?.textContent?.trim(),
          salary: jobEl.querySelector(".salary")?.textContent?.trim(),
          link: jobEl.querySelector("a")?.href,
        };

        if (job.title && job.company) {
          allJobs.push(job);
        }
      }

      // Go to next page if available
      if (page < maxPages) {
        const nextButton = doc.querySelector("#next-page");
        if (nextButton) {
          await client.clickElement("#next-page");
          await new Promise((resolve) => setTimeout(resolve, 3000));
        } else {
          console.log("No more pages available");
          break;
        }
      }
    }

    console.log(`Scraped ${allJobs.length} job listings`);
    return allJobs;
  } catch (error) {
    console.error("Scraping failed:", error);
    return allJobs; // Return what we have so far
  }
}

// Usage
const jobs = await scrapeJobListings("software engineer", 3);
console.log(jobs);
```

### Automated Testing

Test web application functionality:

```javascript
async function testLoginFunctionality() {
  const client = new MCPXClient();
  const testCases = [
    {
      name: "Valid credentials",
      email: "test@example.com",
      password: "validpassword",
      expectedResult: "success",
    },
    {
      name: "Invalid email",
      email: "invalid-email",
      password: "anypassword",
      expectedResult: "error",
    },
    {
      name: "Empty password",
      email: "test@example.com",
      password: "",
      expectedResult: "error",
    },
  ];

  const results = [];

  for (const testCase of testCases) {
    console.log(`Running test: ${testCase.name}`);

    try {
      // Open fresh login page
      await client.openTab("https://example.com/login");
      await new Promise((resolve) => setTimeout(resolve, 2000));

      // Fill in credentials
      await client.typeText("#email", testCase.email, true);
      await client.typeText("#password", testCase.password, true);

      // Submit form
      await client.clickElement("#login-button");
      await new Promise((resolve) => setTimeout(resolve, 3000));

      // Check result
      const snapshot = await client.call("snapshot", { url: "current" });
      const parser = new DOMParser();
      const doc = parser.parseFromString(snapshot.result.dom, "text/html");

      let actualResult;
      if (doc.querySelector(".success-message")) {
        actualResult = "success";
      } else if (doc.querySelector(".error-message")) {
        actualResult = "error";
      } else {
        actualResult = "unknown";
      }

      const passed = actualResult === testCase.expectedResult;

      results.push({
        name: testCase.name,
        expected: testCase.expectedResult,
        actual: actualResult,
        passed,
      });

      console.log(`Test ${passed ? "PASSED" : "FAILED"}: ${testCase.name}`);
    } catch (error) {
      console.error(`Test ERROR: ${testCase.name}`, error);
      results.push({
        name: testCase.name,
        expected: testCase.expectedResult,
        actual: "error",
        passed: false,
        error: error.message,
      });
    }
  }

  // Print summary
  const passed = results.filter((r) => r.passed).length;
  const total = results.length;
  console.log(`\nTest Summary: ${passed}/${total} tests passed`);

  return results;
}

// Usage
const testResults = await testLoginFunctionality();
```

## Python Examples

### Data Collection Script

```python
import asyncio
import csv
from mcpx_client import MCPXClient

async def collect_product_data(urls, output_file):
    """Collect product data from multiple URLs and save to CSV"""
    client = MCPXClient()
    products = []

    for url in urls:
        try:
            print(f"Processing {url}...")

            # Open product page
            await client.open_tab(url)
            await asyncio.sleep(2)

            # Get page content
            snapshot = await client.call("snapshot", {"url": url})

            # Extract data (use BeautifulSoup for real implementation)
            product = {
                'url': url,
                'title': 'Product Title',  # Extract from DOM
                'price': '$99.99',         # Extract from DOM
                'rating': '4.5'            # Extract from DOM
            }

            products.append(product)

        except Exception as e:
            print(f"Error processing {url}: {e}")

    # Save to CSV
    with open(output_file, 'w', newline='') as csvfile:
        fieldnames = ['url', 'title', 'price', 'rating']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(products)

    print(f"Saved {len(products)} products to {output_file}")

# Usage
urls = [
    "https://shop.example.com/product/1",
    "https://shop.example.com/product/2",
    "https://shop.example.com/product/3"
]

asyncio.run(collect_product_data(urls, "products.csv"))
```

## Best Practices

1. **Always add delays** - Web pages need time to load and respond
2. **Use try-catch blocks** - Network and browser operations can fail
3. **Be specific with selectors** - Use unique IDs or specific classes
4. **Handle timeouts gracefully** - Set reasonable timeouts for operations
5. **Test incrementally** - Build complex workflows step by step
6. **Log your progress** - Add console.log statements for debugging

## Error Handling

Common patterns for handling errors:

```javascript
// Handle element not found
async function safeClick(client, selector, timeout = 10000) {
  const startTime = Date.now();

  while (Date.now() - startTime < timeout) {
    try {
      await client.clickElement(selector);
      return true;
    } catch (error) {
      if (error.message.includes("not found")) {
        // Wait a bit and try again
        await new Promise((resolve) => setTimeout(resolve, 500));
        continue;
      } else {
        throw error; // Re-throw other errors
      }
    }
  }

  throw new Error(`Element ${selector} not found within ${timeout}ms`);
}
```

---

_For more configuration options and troubleshooting, see our [Configuration](/docs/configuration) and [Troubleshooting](/docs/troubleshooting) guides._
